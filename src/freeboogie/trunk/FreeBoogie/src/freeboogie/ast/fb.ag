// This is the abstract grammar for FreeBoogie used to generate
// the AST. See also the template (*.tpl) files.

// Program organization
Program = Declaration! decl, Program tail;
Declaration :> TypeDecls, ConstantDecls, Function, Axiom, VariableDecls, 
               Procedure, Implementation;

// Types and constants
Type :> PrimitiveType, UserType, ArrayType, MatrixType, GenericType, DepType;
ArrayType = Type! rowType, Type! colType, Type! elemType;
PrimitiveType = enum(Ptype: BOOL, INT, REF, NAME, ANY) val;
GenericType = Type! param, Type! type;
DepType = Type! type, Expr! pred;
TypeDecls = String! name, TypeDecls tail;
ConstantDecl = String! id, Type! type;
UserType = String! name;

// Signatures are used to represent uninterpreted functions
Signature = String! name, VariableDecls args, VariableDecls results;
Axiom = Expr! expr;

// Procedures and implementations
Procedure = Signature! signature, Specification spec, Body body;
Specification = enum(SpecType: REQUIRES, MODIFIES, ENSURES) type,
                Expr! expr, Specification tail;
Implementation = Signature! signature, Body! body;
Body = VariableDecls vars, Blocks blocks;
Blocks = String! name, Commands cmds, BlockEnd! end, Blocks tail;
BlockEnd = enum(BlockType: GOTO, RETURN) type, Identifiers dest;

// Commands
Commands = Command! cmd, Commands tail;
Command :> AssignmentCmd, AssertAssumeCmd, HavocCmd, CallCmd;
AssignmentCmd = Expr! lhs, Expr! rhs; // TODO: define exactly what lhs can be
AssertAssumeCmd = enum(CmdType: ASSERT, ASSUME) type, Expr! expr;
HavocCmd = String! name;
CallCmd = String! function, Identifiers results, Exprs args;

// Expressions
Expr :> BinaryOp, UnaryOp, Atom;
BinaryOp = enum(Op: PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, LT, LE,
                    GE, GT, SUBTYPE, EQUIV, IMPLIES, AND, OR) op,
           Expr! left, Expr! right;
UnaryOp = enum(Op: MINUS, NOT) op, Expr! e;
Atom :> AtomLit, AtomNum, AtomId, AtomFun, AtomOld, AtomCast, AtomQuant, AtomIdx;
AtomLit = enum(AtomType: FALSE, TRUE, NULL) val;
AtomNum = int val;
AtomId = String! id;
AtomFun = String! function, Exprs args;
AtomOld = Expr! e;
AtomCast = Expr! e, Type! type;
AtomQuant = enum(QuantType: EXISTS, FORALL) quant, VariableDecls! vars, Expr! e;
AtomIdx = Atom! atom, Index! idx;
Index = Expr! a, Expr b;

// Some simple lists
Identifiers = String! name, Identifiers tail;
Exprs = Expr! expr, Exprs tail;
VariableDecls = String name, Type! type, VariableDecls tail;

// TODO: the invariants
Specification: type==Type.MODIFIES ==> \typeof(expr)==AtomId

