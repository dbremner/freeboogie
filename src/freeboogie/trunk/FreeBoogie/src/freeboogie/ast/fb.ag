// This is the abstract grammar for FreeBoogie used to generate
// the AST. See also the template (*.tpl) files.

// TODO: there is some repetition here (the tail). Make the
// code generator smarter

// The program is a (functional) list of (global) declarations
Declaration :> TypeDecl, ConstDecl, Function, Axiom, 
               VariableDecl, Procedure, Implementation;

TypeDecl =     String! name, Declaration tail;
ConstDecl=     String! id, Type! type, Declaration tail;
Function =     Signature! sig, Declaration tail;
Axiom =        Expr! expr, Declaration tail;
VariableDecl = String name, Type! type, Declaration tail;
Procedure =    Signature! sig, Specification spec, Body body,
               Declaration tail;
Implementation = Signature! sig, Body! body,
                 Declaration tail;


// Types and constants
Type :> PrimitiveType, UserType, ArrayType, MatrixType, GenericType, DepType;
ArrayType = Type! rowType, Type colType, Type! elemType;
PrimitiveType = enum(Ptype: BOOL, INT, REF, NAME, ANY) ptype;
GenericType = Type! param, Type! type;
DepType = Type! type, Expr! pred;
UserType = String! name;

// Signatures are used to represent uninterpreted functions
Signature = String! name, Declaration args, Declaration results;

// Procedures and implementations
Specification = enum(SpecType: REQUIRES, MODIFIES, ENSURES) type,
                Expr! expr, boolean free, Specification tail;
Body = Declaration vars, Block blocks;
Block = String! name, Commands cmds, BlockEnd! end, Block tail;
BlockEnd = enum(BlockType: GOTO, RETURN) type, Identifiers dest;

// Commands
Commands = Command! cmd, Commands tail;
Command :> AssignmentCmd, AssertAssumeCmd, HavocCmd, CallCmd;
AssignmentCmd = Expr! lhs, Expr! rhs; // TODO: define exactly what lhs can be
AssertAssumeCmd = enum(CmdType: ASSERT, ASSUME) type, Expr! expr;
HavocCmd = String! name;
CallCmd = String! function, Identifiers results, Exprs args;

// Expressions
Expr :> BinaryOp, UnaryOp, Atom;
BinaryOp = enum(Op: PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, LT, LE,
                    GE, GT, SUBTYPE, EQUIV, IMPLIES, AND, OR) op,
           Expr! left, Expr! right;
UnaryOp = enum(Op: MINUS, NOT) op, Expr! e;
Atom :> AtomLit, AtomNum, AtomId, AtomFun, AtomOld, AtomCast, AtomQuant, AtomIdx;
AtomLit = enum(AtomType: FALSE, TRUE, NULL) val;
AtomNum = int val;
AtomId = String! id;
AtomFun = String! function, Exprs args;
AtomOld = Expr! e;
AtomCast = Expr! e, Type! type;
AtomQuant = enum(QuantType: EXISTS, FORALL) quant, Declaration! vars, Expr! e;
AtomIdx = Atom! atom, Index! idx;
Index = Expr! a, Expr b;

// Some simple lists
Identifiers = String! name, Identifiers tail;
Exprs = Expr! expr, Exprs tail;

// TODO: the invariants
Specification: type==Type.MODIFIES ==> \typeof(expr)==AtomId

