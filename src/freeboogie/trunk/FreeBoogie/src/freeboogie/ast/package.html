<html>
<head></head>

<body>

<p>Data structures for representing the abstract syntax tree of BoogiePL.</p>

<p><b>Author</b>: rgrig, reviewed by NAME (DATE)</p>


<h2>Principles</h2>

<ul>
<li>few AST nodes
<li>support pretty print and verbose dump for debug
<li>must be able to parse/print programs and program fragments (expr, stmt)
<li>must read from both streams and strings (TODO: is there a stream
   wrapper around a string?)
<li>good location tracking for error reporting
</ul>

<p>NOTE: <a href="http://manju.cs.berkeley.edu/cil/">CIL</a> has a pretty 
  good design. I will borrow heavily from that.</p>

<h2>The abstract grammar</h2>

<p>The AST is kept as flat as possible.</p>

<p>
The abstract syntax is described using the following language.
An inheritance rule <tt>A :> B, C</tt> means that classes <code>B</code>
and <code>C</code> are derived from <code>A</code>. The composition rule
<code>A = B f1, C f2</code> means that class <code>A</code> has a field
<code>f1</code> of type <code>B</code> and a field <code>f2</code> fo type
<code>C</code>. In this context a type (<code>B</code> or <code>C</code>)
can have the special form <tt>enum(ENUM_NAME: VAL1, VAL2, ...)</tt>.
All the values corresponding to a certain enum name (there might be more than
one occurence of the name!) appear in an enum declaration embedded in the
current class. A type name followed by an exclamation mark means that 
that reference must be non-null.
</p>

<p>
The data structures are functional. The lists are implemented in the usual
head/tail (or singly linked, depending on where you come from) style. There
are no setter methods.
</p>

<pre>
// Program organization
Program = Declaration! decl, Program tail;
Declaration :> TypeDecl, ConstantDecl, Function, Axiom, VariableDecl, 
               Procedure, Implementation;

// Types and constants
Type :> PrimitiveType, Identifier, ArrayType, MatrixType;
ArrayType = Type! indexType, Type! elemType;
MatrixType = Type! rowType, Type! colType, Type! elemType;
PrimitiveType = enum(Literal: BOOL, INT, REF, NAME, ANY) val;
TypeDecl = String! name;
ConstantDecl = String! id, Type! type;

// Uninterpreted functions, axioms, and global variables
Function = String! name, Parameters args, Parameters results;
Parameters = VariableDecl! parameter, Parameters tail;
Axiom = Expr! expr;
VariableDecl = String name, Type! type; // split the case were name is mandatory?

// Procedures and implementations
Procedure = Function! signature, Specification spec, Body body;
Specification = enum(Type: REQUIRES, MODIFIES, ENSURES) type,
                Expr! expr, Specification tail;
Implementation = Function! signature, Body! body;
Body = LocalDecls vars, Block! block;
LocalDecls = VariableDecl! decl, LocalDecls tail;
Block = String! name, Commands cmds, BlockEnd! end;
BlockEnd = enum(Type: GOTO, RETURN) type, Identifiers dest;

// Commands
Commands = Command! cmd, Commands tail;
Command :> AssignmentCmd, AssertAssumeCmd, HavocCmd, CallCmd;
AssignmentCmd = String! lhs, Index idx, Expr! rhs;
AssertAssumeCmd = enum(Type: ASSERT, ASSUME) type, Expr! expr;
HavocCmd = String! name;
CallCmd = String! function, Identifiers results, Exprs args;
Index = Expr! a, Expr b

// Expressions
Expr :> BinaryOp, UnaryOp, Atom;
BinaryOp = enum(Op: PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, LT, LE
                    GE, GT, SUBTYPE, EQUIV, IMPLIES, AND, OR) op,
           Expr! left, Expr! right;
UnaryOp = enum(Op: MINUS, NOT) op, Expr! e;
Atom :> AtomLit, AtomNum, AtomId, AtomFun, AtomOld, AtomCast, AtomQuant;
AtomLit = enum(Type: FALSE, TRUE, NULL) val;
AtomNum = int val;
AtomId = String! id;
AtomFun = String! function, Exprs args;
AtomOld = Expr! e;
AtomCast = Expr! e, Type! type;
AtomQuant = enum(Type: EXISTS, FORALL) quant, VariableDecls! vars, Expr! e;

// Some simple lists
Identifiers = String! name, Identifiers tail;
Exprs = Expr! expr, Exprs tail;
VariableDecls = VariableDecl! decl, VariableDecls tail;

// Extra invariants
Specification: type==Type.MODIFIES ==> \typeof(expr)==Identifier;
</pre>

<h2>TODO</h2>

<p>Transformer (path compression), parsing of subexprs, strings/streams 
(or should I put some of these in freeboogie.parser?)</p>

<p>The parser is generated with ANTLR. I must study if it's possible
to provide wrappers that offer the CIL interface: Parse.expr("x+2").</p>

</body>

</html>