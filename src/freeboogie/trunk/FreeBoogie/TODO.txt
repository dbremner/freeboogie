 . Add formal generics to ensures/requires.
 . Test typechecker thoroughly.
 . Does ImplementationChecker treat type vars correctly?
 . Add the "-old" flag to make freeboogie accept constructs that
   I intend to deprecate.
 . Allow <x>T <: T only in "old" mode.
 . Figure out the general rule that transforms
     axiom (forall h:[<x>name]x, f:name :: old(h[f])==h[f])
   into
     axiom<y> (forall h<x>:[<x>name]x, f:<y>name :: old(h[f])==h[f])
 . Add implicit type variables (h:[ref,<x>name]x -> h<x>:[ref...)
 . The comments and code disagree for TypeChecker.checkExact
 . Check that everything in the functional/parser test typechecks
   in "compatibility mode"
 . Finish passivate; now you can use fancy generics to deal with arrays
 . Desugar dependent types in assumes/asserts
 . Desugar function calls into assumes/asserts (remember that free is special)
 . Desugar specs into assumes/asserts (introduces two? new blocks)
 . Transform BoogiePL expressions into SmtTerms (SmtTermBuilder)
   Take care of arrays (does the prover know about arrays?)
 . Extract sharing in SimplifyProver, or use `flet' for z3
 . When making SmtTerms do small simplifications for "and", "or"
   (such as skip "TRUE", respectively "FALSE"; and return
   neutral element when there are no operands)
 . Cut out loops
 . Make flowgraph reducible
 . Simple interface to parse from strings
 . Support for explicit specialization in typechecker

vim:spell:ts=3:sw=3:fdm=manual:
