This file contains a history of the design decisions that were
taken and their motivation.

Principle: Treat arrays as functions (NOT procedures) as much as possible.

We introduced generics in BoogiePL so that we can write
  var heap<x> : [ref,<x>name]x;
  procedure store<x,y,z>([x,y]z,x,y,z) returns ([x,y]z);
To specialize we write
  heap' := store<`ref,`<int>name,`int>(heap<`int>,obj,int_field,3);
Specialization is completely optional. The ` is used to keep
the parser simple. If omitted, then in
  call p(a<b,c<d,e<f,g<h)
the parser could figure out only at the very end that the '<'
signs mean "less than", not specialization. Even so, the grammar
uses an syntactic predicate for stuff like
  call a<`[[[int]int]int]int>, b, c := procThatReturnsTriple();
to look and see if there is an ':=' or not. The problem is that
you can have arbitrary long types before you see whether you are
calling a specialized function or simply specialize an ID. (The
existence of _any_ type constructor makes types arbitrary long.)


The construct
  var heap : [ref,<x>name]x;
is not legal anymore, but I plan to make it so in a 'compatibility'
mode. In 'compatibility mode' FB is supposed to do some extra
preprocessing of the source produced by Boogie to make it
legal FB code.


Arrays should be allowed to be used as indices within arrays.
This is similar to sending an array as an argument to a function.
(Of course, one could also argue that functions should be
good indices too by a reversed argument. And that would probably
be good but seems too hard for now.) A consequence is that in
VC generation we need to add `extensionality axioms' for arrays.
These are needed anyway if the user says
  assume a == b;
with a and b being arrays. 


I allow type variables in axioms so that it's possible to write
  function select<x,y>([x]y,x) returns (y);
  function update<x,y>([x]y,x,y) returns ([x]y);
  axiom<x,y> (forall a:[x]y,i:x,v:y:: select(update(a,i,v),i)==v);
The placement of the type variable introduction is consistent
if you imagine that axioms have an empty name. In fact I may
consider naming them in the future.

I must allow generics on all variable declarations. Otherwise I
can't express things like
  const i : <int>name;
  const v : int;
  axiom (forall h<x>:[<x>name]x :: h[i] == v);
Note that moving the <x> on the axiom does not typecheck.

vim:spell:fdm=manual:
