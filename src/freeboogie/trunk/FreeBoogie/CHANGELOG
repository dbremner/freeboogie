This file contains a history of the design decisions that were
taken and their motivation.

Principle: Treat arrays as functions as much as possible.

We introduced generics in BoogiePL so that we can write
  var heap<x> : [ref,<x>name]x;
  procedure store<x,y,z>([x,y]z,x,y,z) returns ([x,y]z);
To specialize we write
  heap' := store<`ref,`<int>name,`int>(heap<`int>,obj,int_field,3);
Specialization is completely optional. The ` is used to keep
the parser simple. If omitted, then in
  call p(a<b,c<d,e<f,g<h)
the parser could figure out only at the very end that the '<'
signs mean "less than", not specialization. Even so, the grammar
uses an syntactic predicate for stuff like
  call a<`[[[int]int]int]int>, b, c := procThatReturnsTriple();
to look and see if there is an ':=' or not. The problem is that
you can have arbitrary long types before you see whether you are
calling a specialized function or simply specialize an ID. (The
existence of _any_ type constructor makes types arbitrary long.)


The construct
  var heap : [ref,<x>name]x;
is not legal anymore, but I plan to make it so in a 'compatibility'
mode. In 'compatibility mode' FB is supposed to do some extra
preprocessing of the source produced by Boogie to make it
legal FB code.

I will allow arrays to be used as indices in arrays because
I don't see why not. (I tend to think that it is confusing
to use such a construct but I blame it on not having any
concrete use in mind.)


I allow type variables in axioms so that it's possible to write
  function select<x,y>([x]y,x) returns (y);
  function update<x,y>([x]y,x,y) returns ([x]y);
  axiom<x,y> (forall a:[x]y,i:x,v:y:: select(update(a,i,v),i)==v);
The placement of the type variable introduction is consistent
if you imagine that axioms have an empty name. In fact I may
consider naming them in the future.


vim:spell:fdm=manual:
