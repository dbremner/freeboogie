// This is the abstract grammar for FreeBoogie used to generate
// the AST. See also the template (*.tpl) files.

Program =
  String fileName,
  [list] TypeDecl types,
  [list] Axiom axioms,
  [list] VariableDecl variables,
  [list] ConstDecl constants, 
  [list] FunctionDecl functions,
  [list] Procedure procedures,
  [list] Implementation implementations;

// Provide a common class for AST nodes that can act as a
// definition for an AtomId.
IdDecl :> 
  ConstDecl, 
  VariableDecl;
IdDecl =
  String! name,
  Type! type;

// Group all elements that can have attributes.
Declaration :> 
  TypeDecl, 
  Axiom, 
  IdDecl, 
  FunctionDecl, 
  Procedure, 
  Implementation;
Declaration =
  [list] Attribute attributes;

TypeDecl = 
  boolean finite, 
  String! name,
  [list] AtomId typeArgs, // TODO(radugrigore): remane to typeVars
  Type type; // non-null when this is a type synonym
Axiom =
  String! name,
  [list] AtomId typeArgs,
  Expr! expr;
VariableDecl =
  [list] AtomId typeArgs,
  Expr where;
ConstDecl = 
  boolean uniq;
FunctionDecl = 
  Signature! sig;
Procedure =
  Signature! sig,
  [list] PreSpec preconditions,
  [list] PostSpec postconditions,
  [list] ModifiesSpec modifies;
Implementation =
  Signature! sig,
  Body! body;

// Types and constants
Type :> 
  MapType, 
  PrimitiveType, 
  TupleType,
  UserType;
MapType = 
  [list] Type idxTypes,
  Type! elemType;
PrimitiveType = 
  enum(Ptype: BOOL, INT, REF, NAME, ANY, BV, ERROR) ptype,
  int bits;
TupleType =
  [list] Type types;
UserType = 
  String! name, 
  [list] Type typeArgs;

// Signatures are used to represent uninterpreted functions
Signature = 
  String! name, 
  [list] AtomId typeArgs,
  [list] VariableDecl args,
  [list] VariableDecl results;

// Procedures and implementations
Specification :> 
  PrePostSpec,
  ModifiesSpec;
Specification =
  boolean free;
PrePostSpec :>
  PreSpec,
  PostSpec;
PrePostSpec =
  [list] AtomId typeArgs,
  Expr! expr;
ModifiesSpec =
  [list] AtomId ids;
Body = 
  [list] VariableDecl vars,
  Block! block;
Block =
  [list] Command commands; 

// Commands
Command :> 
  AssignmentCmd, 
  AssertAssumeCmd, 
  GotoCmd,
  HavocCmd, 
  CallCmd, 
  WhileCmd;
Command =
  [list] String labels;
AssignmentCmd = 
  AtomId! lhs, 
  Expr! rhs;
AssertAssumeCmd = 
  enum(CmdType: ASSERT, ASSUME) type, 
  [list] AtomId typeArgs, 
  Expr! expr;
GotoCmd =
  [list] String successors; // if successors.isEmpty() then it's "return"
HavocCmd = 
  [list] AtomId ids;
CallCmd = 
  String! procedure, 
  [list] Type types, 
  [list] AtomId results,
  [list] Expr args;
WhileCmd = 
  Expr condition, 
  [list] LoopInvariant inv, 
  Block body;
LoopInvariant = 
  boolean free, 
  Expr! expr;

Attribute = 
  String! type, 
  [list] Expr exprs;

// Expressions
Expr :> 
  BinaryOp, 
  UnaryOp, 
  Atom;
BinaryOp = 
  enum(Op:PLUS,MINUS,MUL,DIV,MOD,EQ,NEQ,LT,LE,GE,GT,SUBTYPE,EQUIV,IMPLIES,AND,OR) op,
  Expr! left, 
  Expr! right;
UnaryOp = 
  enum(Op: MINUS, NOT) op, 
  Expr! expr;
Atom :> 
  AtomCast,
  AtomFun,
  AtomId,
  AtomLit,
  AtomMapSelect,
  AtomMapUpdate,
  AtomNum,
  AtomOld,
  AtomQuant;
AtomLit = 
  enum(AtomType: FALSE, TRUE, NULL) val;
AtomNum = 
  BigInteger val;
AtomId = 
  String! id, 
  [list] Type types;
AtomFun = 
  String! function, 
  [list] Type types, 
  [list] Expr args;
AtomOld = 
  Expr! expr;
AtomCast = 
  Expr! expr, 
  Type! type;
AtomQuant =
  enum(QuantType: EXISTS, FORALL) quant,
  [list] VariableDecl vars,
  [list] Attribute attributes,
  Expr! expression;
AtomMapSelect = 
  Atom! atom, 
  [list] Expr idx;
AtomMapUpdate = 
  Atom! atom, 
  [list] Expr idx, 
  Expr! val;

// the invariants
AtomMapSelect: !idx.isEmpty()
AtomMapUpdate: !idx.isEmpty()
HavocCmd: !ids.isEmpty()
PrimitiveType: ptype == Ptype.BV || bits == -1
Body: !block.commands().isEmpty() && block.commands().get(block.commands.size()-1) instanceof GotoCmd

// TODO(radugrigore): rename using whole words
